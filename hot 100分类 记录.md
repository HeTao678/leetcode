# 1.哈希

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

①哈希表怎么建表，unordered_map(key类型,value类型)，未初始化，value默认为0 

  最常用（元素大小nums[i]，频率出现次数） 

  很少用（元素大小nums[i]，对应下标i）会有重复的覆盖下标，为了防止重复，建表和查找在一个循环里（1.两数之和）

```C++
for(int i=0;i<nums.size();i++){
            mymap[nums[i]]++;
}
for(int i=0;i<nums.size();i++){//（元素大小nums[i]，对应下标i）,仅适用无重复元素，因为key不能重复，这样会覆盖下标
            mymap[nums[i]]=i;
}
```

② 查找key,可以不用初始化进行下标操作，

**★★★要找的key一定存在，用A，不一定存在用B**

A：mymap[key] 就是value –这种查找若key不存在，会增加无意义的条目，修改哈希表

B.find(key)返回迭代器  if (mymap.find(complement) != mymap.end())  

查找value只能遍历  用pair:

```C++
for (const auto& pair : myMap) {
        if (pair.second == targetValue) 
```

③删除键值对，几乎不用，注意键值对插入之后，只能用erase删除了，size才会变

④错误：if(mymap.find(nums[i]-1)==mymap.end())  是= = 不是 ！=,find查到末尾才是不存在，

然后你必须用一个currnum保存nums[i],防止修改nums[i]；

int maxlen=0;//空数组长度为0，注意特殊情况max初始值

## 1.两数之和:X

2024.11.22

本质是查找问题，两次查找，凑起来等于target,一个是nums[i]，另个nums[j]=target-nums[i]，

坑就在：不准下标重复元素   i!=j

★★★而且这道题不能一次性把所有数组元素和下标存到map里，会有重复元素，key又是唯一，会覆盖下标

★★★而且可以一次遍历，因为先查第一个找不到第二个，但是后面查到第二个的时候，第一个肯定存在

★★★另一个数不一定存在，所以用find查找，下标查找会增加新条目

重复元素覆盖也无所谓，因为只有他找不到，才会被覆盖，覆盖了也不会干嘛，后面也不会再找他了

![image-20241123140911881](hot 100分类 记录.assets/image-20241123140911881.png)



## 49.字母异位词分组X

2024.11.23

关键是怎么检查 单词是否属于同一个分组的异位词—

1. **排序字符**：将每个字符串按字母顺序排序后，相同字母异位词会变成相同的字符串。例如，`"eat"` 和 `"tea"` 排序后都变为 `"aet"`。
2. **哈希表存储**：将排序后的字符串作为键，将原字符串作为值存储在哈希表中，最终哈希表中相同键的字符串就是字母异位词。
3. 这里map的key是排序好的字符串，value就是字符串数组了他的异味词，然后遍历map收集答案



不用加判断是否为不为空，反正是分类，直接塞进去就是了

移除无效判断：`if(mymap[copy]>0)`再mymap[copy].push_back(str);不用去查找

注意 `unordered_map` 的下标操作会自动初始化键。不存在的会新建键值对，哈希表！

```
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>>mymap;
        for(string str :strs){
            string copy=str;
            sort(copy.begin(),copy.end());
            mymap[copy].push_back(str);
            
            
        }
        vector<vector<string>> ans;
        for(auto pair :mymap){
            ans.push_back(pair.second);
        }
        return ans;
        
    }
};
```



## 128.最长连续序XXXX

2024.11.23

我的代码错的有些离谱了，看注释

```c++
        map<int,int>mymap;
        for(int num :nums){
            mymap[num]++;
        }
        int maxlen=-1,currlen=0;
//比如数组[3,2,1,200] //map就是1,2,3,200, value都是1
        for(auto pair:mymap){
            if(pair.second>0){//一直满足，currlen一直增加，都修改不了maxlen的值，而且不连续也算进去了，错的很离谱
                currlen++;
            }
            if(pair.second==0){
                maxlen=max(maxlen,currlen);
                currlen=0;
            }
        }
        return maxlen;

    }
```

这道题关键在于num在的话，查找num+1在不在无序map即可，因为要求On，用无序map,也用不着有序map

2024.11.24

不能用if(mymap[nums[i]]>0)，因为你下标操作找不到会自动插入新的键值对，

这里可以把value设置当前数字为起点能达到的最大长度，这样后续又找到这个数字的时候不用再循环查找了，比如先计算了100后面可以连续到5的长度，后面从99开始，找到100，直接加上100的长度即可，相当于记忆化搜索

我的代码又错了，直接修改了原数组的值：nums[i]++，导致后面会出错，数都变了

```C++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        //遍历数组，然后查哈希表中是否一直存在下一个元素
        unordered_map<int,int>mymap;
        for(int num:nums){
            mymap[num]++;
        }
        int maxlen=-1;
        for(int i=0;i<nums.size();i++){
            int currlen=0;
            while(mymap.find(nums[i])!=mymap.end()){
                currlen+=mymap[nums[i]];
                nums[i]++;
            }
            mymap[nums[i]]=currlen;
            maxlen=max(maxlen,currlen);
        }
        return maxlen;
    }
};
```

然后我又用个now去存nums[i]，完全没必要，又导致出错了，因为你重复计算，你的本意是currlen+=nums[i],nums[i]存的是他的最终最大长度，可是你初始化的时候nums[i]不是最终的长度，对于大元素你还的重新找，这样小元素才能用到它，如果你非得那样做，要从大往小找，而且得连续数字，很混乱的做法，看题解吧

★只有当前数字是序列的开头时才计算长度

2024.11.25

★这里复杂度的计算我还是出错了，以为是O(n2)，每个数字最多被访问两次（一次作为序列起点，一次在序列中）。

<img src="hot 100分类 记录.assets/image-20241125103246032.png" alt="image-20241125103246032" style="zoom:50%;" />

这里//新起点才要计算if(mymap.find(nums[i]-1)==mymap.end())  是= = 不是 ！=,find查到末尾才是不存在，

然后你必须用一个currnum保存nums[i],防止修改nums[i]；

```C++
    int longestConsecutive(vector<int>& nums) {
        unordered_map<int,int>mymap;
        for(int num:nums){
            mymap[num]++;
        }
        int maxlen=0;//空数组长度为0，注意特殊情况max初始值
        for(int i=0;i<nums.size();i++){
            
            if(mymap.find(nums[i]-1)==mymap.end()){//新起点才要计算
                int  currlen=0;
                int currnum=nums[i];
                while(mymap.find(currnum)!=mymap.end()){
                    currlen++;
                    currnum++;
                }
                maxlen=max(maxlen,currlen);
            }
            
        }
        return maxlen;
    }
```

int maxlen=0;//空数组长度为0，注意特殊情况max初始值

这里可以用set改进，下次来

# 2.双指针

注意要用的是nums[i]还是i，别弄错了，还有i,j什么时候移动 

## 283.移动零√

核心就是把非零数字放前面，管他是什么，非零就占一个位置，用个指针j记录下一个可以放的位置，覆盖也无所谓，然后放完了所有非零元素，然后从j开始填充0

```C++
    void moveZeroes(vector<int>& nums) {
        int j=0;
    for(int i=0;i<nums.size();i++){
        if(nums[i]!=0){
            nums[j]=nums[i];
            j++;
        }
    }
    for(;j<nums.size();j++){
        nums[j]=0;
    }
    
    }
```

每遇到一个0和第一个非0交换位置，双重循环，复杂度高

## 11.盛最多水的容器XX

2024.11.24

思维混乱，以为是接雨水的了



2024.11.25

1.还是做错了，高度是min(height[i],height[j])   而不是min(i,j)

2.一开始还直接while(i<j){  i--,j++  }    这明显移动错了啊，这样一直夹逼，并没有把所有的矩形都计算到

3.然后想着用双重for循环，但是你把int定义写在循坏外面，这样内层j的值并不是每次都重置从最后开始

```C++
    int maxArea(vector<int>& height) {
        int i=0,j=height.size()-1;
        int maxS=-1;
        for(;i<height.size();i++){
            for(;j>i;j--){//内层循环中的 j 是从右向左递减，但在内层循环结束后，j 的值不会重置，这会导致外层循环的后续计算出现问题。实际上，在内层循环完成一次后，j 的值将保持为 i + 1，无法正确计算新的区域。
                maxS=max(min(height[i],height[j])*(j-i),maxS);
            }
        }

        return maxS;
    }
```

题解：https://leetcode.cn/problems/container-with-most-water/solutions/94102/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu

用一句话概括双指针解法的要点：**每一次移动矮柱子指针，都意味着排除掉了一个柱子**。

每次排除掉矮的柱子，移动那根指针，因为保留高柱子才能创造更大的面积，能接受更多可能的矮柱子组合，有点贪心思想

**移动较小的指针**：

- 如果左侧高度较小，则左指针右移。
- 如果右侧高度较小，则右指针左移。

双指针法通过**只移动较小的高度的指针**，在保证所有可能的面积都被考虑到的同时，减少了不必要的重复计算。

## 15.三数之和XXXXX

2024.11.25感觉就是暴力，然后想了想，用map存下标，然后还是没思路，和两数之和不同，无法存下标，因为这里三个数

题解：**升序排序后，先固定一个数nums[i]（从头开始，算一层循环），然后找剩下nums[i]右边的部分的头和尾用两个指针l,r逼近，两个数之和=负的nums[i]=target，三个数和前一个数相等都可以跳过**

**i的移动：**

因为是升序排列，所以当nums[i]>0跳出循环,=0可以继续，如[0，0，0], 

因为是升序排列，nums[i]=nums[i-1]可以跳过循环了

**l,r的移动：**

nums[l]+nums[r]==target,记录结果 

因为是升序排列，nums[l]=nums[l-1]可以跳过了

因为是升序排列，nums[r]=nums[r-1]可以跳过了

因为是升序排列，nums[l]+nums[r]<target,说明两数之和小了，要增大两数之和，右移i,i++

因为是升序排列，nums[l]+nums[r]>target,说明两数之和大了，要缩小两数之和，左移j.j–

2024.11.26

今天写了一下还是错了，

在for循环里，i,l,r都越界了，没控制好边界，而且压入当前答案的时候也错了

```C++
 //错误代码
 vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size();i++){
            if(nums[i]==nums[i+1]) continue;//这里i会越界，因为i遍历到size-1
            int target=-nums[i],l=i+1,r=nums.size()-1;
            
            while(l<r){
                while(nums[l]==nums[l+1])l++;//这里面的两个循环也要时刻检查，虽然一进来的时候检查了l<r，但是后面l一直递增，可能越界
                while(nums[r]==nums[r-1])r--;//可能越界同理
                if(nums[l]+nums[r]==target){//应该把这个压入答案放到循环的最开始的地方
                    ans.push_back({nums[i],nums[l],nums[r]});
                }
                //<target,>target,指针怎么移动已没有写，只写了值相同的时候指针怎么移动
            }
        }
        return ans;
    }
```

关键，1.排序，2.固定i，nums[i]有重复怎么不越界的移动i，3.剩下部分l/r找负的nums[i]，移动指针有两部分，①重复的nums[l]，nums[r]，②两数之和等于目标的时候l,r的移动，移动到下次不重复的③两数之和大于小于目标的时候l,r的移动

```c++
vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        if (nums.size() < 3) return result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = nums.size() - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    result.push_back({nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return result;
    }
```

因为要三个数i只能到nums.size()-3,也就是说i<nums.size()-2

## 42.接雨水hard没做

# 3.滑动窗口

## 3. 无重复字符的最长子串

2024.11.29

我想着用l遍历每个位置开始，然后r从l开始检查，把每个字母加入哈希表，直至他重复了，更新长度，然后检查下一个l，这个l回退到上次l+1，不过我一开始写反了，要先检查是否出现，然后再把出现次数+1，反了先把出现次数+1，再检查是否出现，那肯定出现了呀

```C++
  //我的代码
int lengthOfLongestSubstring(string s) {
        int l=0,r=0,maxlen=0;
        while(l<s.size()){
            unordered_map<char,int>mymap;
            for(;r<s.size();r++){

                if(mymap[s[r]]>0){//两个if位置不能写反
                    break;
                }
                if(mymap[s[r]]==0){
                    mymap[s[r]]++;
                }
            }
            maxlen=max(r-l,maxlen);
            l++;
            r=l;
        }
        return maxlen;
    }
```

题解两种方法  ：

 **①哈希表  ，**—–哈希表储存下次重复字符可以出现的位置，l左指针不回退取max

题解也用了哈希表，不过我的哈希表是回退到上次l+1，都是右指针 `r` 遇到重复字符时，我们需要调整左指针 `l`

而题解的哈希表记录最后一次字符出现过的位置+1（下标），表示mymap[s[r]] = r + 1;//r + 1 表示的是字符 s[r] 下一次可以出现的位置，

题解这个l回退到上次重复字符（也就是当前字符）出现过的地方+1，左指针 `l` 应该跳到重复字符 **上次出现位置的下一个位置**。这样滑动窗口里始终没有重复的字符       

然**而，在调整 `l` 时，可能会遇到以下两种情况：为什么 l = max(mymap[s[r]], l);确保 `l` 不会回退**

1. `l` 已经在重复字符的右侧—————abba扫描到abb的第二个b

   ：如果 `l` 已经在重复字符的右侧，那么我们无需改变 `l`，`l` 仍然应该保持在当前位置。

2. `l` 在重复字符的左侧—————abba扫描到abba的第二个a

   ：如果 `l` 在重复字符的左侧，说明我们需要将 `l` 移动到重复字符的下一个位置，以确保窗口内没有重复字符。

```C++
   int lengthOfLongestSubstring(string s) {
        int l = 0, r = 0, maxlen = 0;
        unordered_map<char, int> mymap;  // 移到外部，避免重复创建哈希表
        // 遍历字符串
        while (r < s.size()) {
            // 如果字符已经出现过，调整左指针
            if (mymap[s[r]] > 0) {
                // 移动左指针，直到去掉重复的字符
                l = max(mymap[s[r]], l);
            }
            mymap[s[r]] = r + 1;//r + 1 表示的是字符 s[r] 下一次可以出现的位置，确保当遇到重复字符时，能够正确地调整左指针 l，避免重复字符的影响。
            maxlen = max(maxlen, r - l + 1);
            r++;
        }
        return maxlen;
    }
```

 ②动态规划方法，下次试试

**定义 `dp[i]` 为以 `s[i]` 结尾的最长无重复字符的子串的长度。**

理解这里的  以 `s[i]` 结尾的     最长无重复字符的子串

具体来说：

- 如果 `s[i]` 在之前的位置 `j` 出现过，那么当前子串的起始位置应该为 `j + 1`，即 `dp[i] = i - j`，其中 `j` 是字符 `s[i]` 上次出现的位置。
- 如果 `s[i]` 在之前的位置没有出现过，那么 `dp[i] = dp[i-1] + 1`。

#### 边界条件：

- 初始时，`dp[0] = 1`，表示以第一个字符结尾的子串长度为 1。

#### 额外空间：

我们可以使用一个哈希表 `last_seen` 来记录每个字符最后一次出现的索引。

## 438. 找到字符串中所有字母异位词